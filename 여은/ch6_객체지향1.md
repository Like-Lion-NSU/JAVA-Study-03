## 객체지향언어
> 1. 코드의 재사용성이 높다 
> 2. 코드의 관리가 용이하다
> 3. 신뢰성이 높은 프로그래밍을 가능하게 한다
  
## 클래스와 객체
### 🟡클래스와 객체의 정의와 용도

    클래스 정의  | 클래스란 객체를 정의해 놓은 것  ex) 붕어빵 기계
    클래스 용도  | 클래스는 객체를 생성하는데 사용된다  
    
    객체 정의    | 실제로 존재하는 것. 사물 또는 개념  ex) 붕어빵
    객체 용도    | 객체가 가지고 있는 기능과 속성에 따라 다름
     
    유형 객체    | 책상, 의자, 자동차, TV오 같은 사물
    무형 객체    | 수학공식, 프로그램 에러와 같은 논리나 개념
    
### 🟡객체와 인스턴스
> 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화
> 클래스로부터 만들어진 객체를 그 클래스의 인스턴스

    클래스 ---인스턴스화--> 인스턴스(객체)
    
### 🟡객체의 구성요소 - 속성과 기능

    속성(property) 멤버변수, 특성, 필드, 상태
    기능(function) 메서드, 함수, 행위
    
    ex) TV 속성 - 크기,길이,높이,색상,볼륨,채널 등
        TV 기능 - 켜기,끄기,볼륨 높이기,볼륨 낮추기,채널 변경하기 등
        
 ### 🟡인스턴스의 생성과 사용
 
    클래스 변수명;    // 클래스의 객체를 참조하기 위한 참조변수를 선언
    변수명 = new 클래스명();  // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
    
    ex) Tv t;   // Tv클래스 타입의 참조변수 t를 선언
        t = new Tv();  // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
        
### 🟡기본형 매개변수와 참조형 매개변수

    기본형 매개변수    | 변수의 값을 읽기만 할 수 있다 (read only)
    참조형 매개변수    | 변수의 값을 읽고 변경할 수 있다 (read & write) 
    
 - - - -
 ## 오버로딩(overloading)
 > 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것

### 🟡오버로딩의 조건

    1. 메서드 이름이 같아야 한다
    2. 매개변수의 개수 또는 타입이 달라야 한다
    
### 🟡오버로딩의 예

    ex1) 매개변수의 이름만 다를 뿐 매개변수의 타입이 같을 경우, 오버로딩 X
    int add(int a, int b) {return a+b; }
    int add(int x, int y) {return x+y; }
    
    ex2) 매개변수의 타입과 개수가 일치, 리턴타입만 다른 경우 , 오버로딩 X
    int add(int a, int b) {return a+b; }
    long add(int a, int b) {return (long)(a+b);}
    
    ex3) int형 long형 매개변수가 하나씩 선언, 순서가 다른 경우 호출 시 
         매개변수의 값에 의해 호출될 메서드가 구분될 수 있으므로 중복된 메서드 정의가 아닌 오버로딩 O
    long add(int a, long b) {return a+b; }
    long add(long a, int b) {return a+b; }
    
- - - -
## 생성자(Constructor)
> 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다

### 🟡생성자의 조건

    1. 생성자의 이름은 클래스의 이름과 같아야 한다
    2. 생성자는 리턴 값이 없다    
    
    클래스이름 (타입 변수명, 타입 변수명 ...) {
         // 인스턴스 생성 시 수행될 코드,
         // 주로 인스턴스 변수의 초기화 코드를 적는다
     }
     class Card {
           Card() {  // 매개변수가 없는 생성자 
                ... 
            }
            Card(String k, int num) {  // 매개변수가 있는 생서자
                ...
            }
            ...
      }    
      

    Card c = new Card();
    
    1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다
    2. 생성자 Card()가 호출되어 수행된다
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다
