##if문
만일(if) 조건식이 참(true)이면 괄호{} 안의 문장들을 수행하라 if (조건식) { 조선식이 참(true)일 때 수행될 문장 }

ex) if (score > 60 ) { 
         System.out.println("합격입니다.");
         }    
##if-else문
만일(if) 조건식이 참(true)이면 괄호{} 안의 문장들을 수행하고 그 밖의(else) 조건식이 거짓(false)이면 else괄호{} 안의 문장을 수행하라

 ex) if (input==0 ) { 
         System.out.println("0입니다.");
         } else {
           System.out.print("0이 아닙니다")
         }
##if-els if문

 한 문장에 여러 개의 조건식을 쓸 수 있다
      if (조건식1 ) { 
          // 조건식1의 연산결과가 참일 때 수행될 문장들을 적는다.
         } else  if (조건식2) {
          // 조건식2의 연산결과가 참일 때 수행될 문장들을 적는다.
         } else  if (조건식3) {
          // 조건식3의 연산결과가 참일 때 수행될 문장들을 적는다.
         } else { // 마지막은 보통 else블럭으로 끝나며, 생략가능하다.
          // 위의 어느 조건식도 만족하지 않을 때 수행될 문장을 적는다.
         }
##중첩 if문

if문의 블럭 내에 또 다른 if문을 포함시키는 것을 중첩 if문이라고 한다
     if (조건식1 ) { 
          // 조건식1의 연산결과가 참일 때 수행될 문장들을 적는다.
          if (조건식2) { 
              // 조건식1과 조건식2가 모두 참일 때 수행될 문장들
         } else {
          // 조건식1이 참이고, 조건식2가 거짓일 때 수행되는 문장들
         } 
    } else { 
           // 조건식1이 거짓일 때 수행되는 문장들
    }
##switch문
처리할 경우의 수가 많은 경우 if문보다 swich문 사용

조건식을 계산한다
조건식의 결과와 일치하는 case문으로 이동한다
이후의 문장들을 수행한다
break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다
switch (조건식) {
       case 값1 : 
              // 조건식의 결과가 값1과 같을 경우 수행될 문장들
              // ...
              break;
       case 값2 : 
              // 조건식의 결과가 값2와 같을 경우 수행될 문장들
              // ...
              break;   // switch문을 벗어난다
        // ...
        default : 
              // 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
              // ...
  }

##반복문
for문의 구조와 수행순서
초기화, 조건식, 증감식, 블럭{} - 4부분으로 이루어져있다.

for (초기화; 조건식; 증감식) {
     // 조건식이 참일 때 수행될 문장들을 적는다.
 }    
##while문
조건식이 '참(true)인 동안', 즉 조건식이 거짓이 될 때까지 블럭{} 내의 문장을 반복한다

while (조건식) { // 조건식 생략불가
       // 조건식의 연산결과가 참(true)인 동안, 반복될 문당들을 적는다
 }

##do-whlie문
조건식과 블럭{}의 순서를 바꿔놓은 것. 블럭{}을 먼저 수행 후 조건식을 평가

do {
    // 조건식의 연산결과가 참일 때 수행될 문장들을 적는다
} whlie (조건식);

##배열의 생성
값을 저장할 수 있는 공간이 만들어지는 것 연산자 'new'와 함께 배열의 타입과 길이를 지정해 주어야 한다

타입[] 변수이름;            // 배열을 선언(배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이];  // 배열을 생성(실제 저장공간을 생성)

##배열의 길이와 인덱스
인덱스 - 배열의 요소마다 붙여진 일련번호
인덱스의 범위는 0부터 '배열길이 -1'까지'

ex) int[] score = new int[5] // 길이가 5인 int 배열, 인덱스의 범위는 0부터 4까지

##배열의 초기화
배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화 되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 된다. 
원하는 값을 저장하려면 요소마다 값을 지정해 줘야한다.

int[] score = new int[5]; //길이가 5인 int형 배열을 생성한다.
score [0] = 50;   // 각 요소에 직접 값을 저장한다
score [1] = 60;
score [2] = 70;
score [3] = 80;
score [4] = 90;

##객체지향언어
1. 코드의 재사용성이 높다.
새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

##클래스와 객체의 정의와 용도
클래스의 정의  클래스란 객체를 정의해 놓은 것  ex) 붕어빵 기계
클래스의 용도  클래스는 객체를 생성하는데 사용된다  

객체의 정의    실제로 존재하는 것. 사물 또는 개념  ex) 붕어빵
객체의 용도    객체가 가지고 있는 기능과 속성에 따라 다름
 
유형의 객체    책상, 의자, 자동차, TV오 같은 사물
무형의 객체    수학공식, 프로그램 에러와 같은 논리나 개념

##인스턴스의 생성과 사용
클래스 변수명;    // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();  // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

ex) Tv t;   // Tv클래스 타입의 참조변수 t를 선언
    t = new Tv();  // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

##오버로딩(overloading)
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것

##오버로딩의 조건
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
