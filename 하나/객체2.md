# 객체지향2

## 상속

### 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

장점:  코드의 재사용성을 높임, 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여

사용법: extends를 이용하여 사용

예시> 자식클래스 extends 부모클래스

용어

조상 클래스: 부모클래스, 상위 클래스

자손 클래스: 자식 클래스, 하위 클래스

<aside>
📢 주의사항                                                                                                                                                       -생성자와 초기화 블럭은 상속되지 않음, 멤버만 상속                                                                        -자손 클래스의 멤버 개수는 조상 클래스보다 같거나 많아야함

</aside>  

***  

## 포함관계

### 상속을 하지 않고 클래스를 재사용하는 방법

클래스의 멤버변수로 다른 클래스 타입의 참조 변수를 선언하는 것

```java
class Point {
int x;
int y;
}

class Circle {
Point c = new Point(); //Point클래스를 멤버변수로 선언하여 포함시킨다.
int r
}
```

### 클래스간의 관계 결정
📢 ~은 ~이다.  ⇒ 상속관계  
~은 ~을 가지고 있다 ⇒ 포함 관계                                                                                                        
예시> 원은 점이다. (x) / 원은 점을 가지고 있다. (o) 이므로 포함 관계가 더 적절함  

***
 
## Object 클래스

### 모든 클래스들의 조상 클래스

컴파일러가 자동으로 extends Object를 추가해줌 

***

## 오버로딩 vs 오버라이딩  

| 비교 요소 | 메서드 오버라이딩 | 메서드 오버로딩 |
| --- | --- | --- |
| 메서드 이름 | 동일 | 동일 |
| 매개변수 | 동일 | 다르다 |
| 반환 타입 | 동일 | 관계 없음 |
| 상속 관계 | 필요 | 필요 없다 |
| 예외와 접근 범위 | 제약이 있다 | 제약이 없다 |
| 바인딩 | 호출할 메소드를 실행 중 결정하는 동적 바인딩이다. | 호출할 메서드를 컴파일 할 때 결정하는 정적 바인딩이다. |  

*** 

## Interface

### 오직 추상 메서드와 상수만을 멤버로 가질 수 있음

class 대신 interface를 작성

- 인터페이스는 다중 상속이 가능
- 인터페이스를 구현할 때는 구현할 클래스에 implements와 인터페이스 이름을 명시

***  

## 접근제어자 범위  
| 접근 제어자	| 같은 클래스의 멤버 |	같은 패키지의 멤버	| 자식 클래스의 멤버 |	그 외의 영역 |
| --- | --- | --- | --- | --- |
| public |	○	| ○ |	○	| ○ |
| protected	| ○	| ○	| ○	| X |
| default	| ○	| ○	| X	| X |
| private	| ○	| X	| X	| X |

## 내부클래스

### 클래스 내에 선언되는 클래스

- 코드의 복잡성을 줄일 수 있음
- 외부클래스의 멤버에 쉽게 접근 가능

**내부 클래스 종류**

- 인스턴스 **클래스** 이름이 같은 외부 **클래스** 메서드 호출 인스턴스 **클래스** 컴파일
- 스태틱 **클래스** static **클래스**에 대한 오해 **내부 클래스**는 static **클래스**로 선언하자 ...
- 로컬 **클래스** 로컬 **클래스** 지역 상수 접근 로컬 **클래스** 컴파일
- 익명 **클래스** 익명 **클래스** 컴파일
